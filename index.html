<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>문제정의 아키타입 진단 (Preview)</title>

  <!-- React & Libraries (Stable Version for Standalone) -->
  <script src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/history@5/umd/history.production.min.js"></script>
  <!-- React Router v5 -->
  <script src="https://unpkg.com/react-router-dom@5.3.4/umd/react-router-dom.min.js"></script>
  <script src="https://unpkg.com/framer-motion@4.1.17/dist/framer-motion.js"></script>

  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* CSS Variables */
    :root {
      --color-bg: #FAFAFA;
      --color-surface: #FFFFFF;
      --color-text-main: #222222;
      --color-text-sub: #4A4A4A;
      --color-text-muted: #888888;
      --color-accent: #3344DD;
      --color-accent-subtle: #EBEFFE;
      --color-border: #EEEEEE;
      --color-card-bg: #F5F5F7;
      --font-main: -apple-system, BlinkMacSystemFont, "Pretendard", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;

      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 20px;
      --space-6: 24px;
      --space-8: 32px;
      --space-10: 40px;
      --space-12: 48px;

      --max-width: 460px;
    }

    /* Global Reset & Styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: var(--font-main);
      background-color: var(--color-bg);
      color: var(--color-text-main);
      line-height: 1.6;
    }

    #root {
      display: flex;
      justify-content: center;
      min-height: 100vh;
      width: 100%;
    }

    .app-container {
      width: 100%;
      max-width: var(--max-width);
      background-color: var(--color-surface);
      min-height: 100vh;
      position: relative;
      display: flex;
      flex-direction: column;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.03);
    }

    /* Typography */
    .text-h1 {
      font-size: 26px;
      font-weight: 700;
      line-height: 1.3;
      margin-bottom: var(--space-4);
      letter-spacing: -0.02em;
    }

    .text-h2 {
      font-size: 20px;
      font-weight: 600;
      line-height: 1.35;
      margin-bottom: var(--space-3);
      letter-spacing: -0.01em;
    }

    .text-h3 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: var(--space-2);
      color: var(--color-text-main);
    }

    .text-body {
      font-size: 16px;
      color: var(--color-text-sub);
      margin-bottom: var(--space-3);
      word-break: keep-all;
    }

    .text-small {
      font-size: 14px;
      color: var(--color-text-muted);
    }

    button {
      border: none;
      background: none;
      font-family: inherit;
      cursor: pointer;
    }

    .screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: var(--space-6);
      padding-bottom: var(--space-10);
    }

    /* Markdown-like content styling 
       UPDATED: Removed explicit colors to allow inheritance for 'highlight' mode */
    .content-block h3 {
      font-size: 16px;
      font-weight: 700;
      margin-top: 24px;
      margin-bottom: 8px;
      color: inherit;
    }

    .content-block p {
      font-size: 15px;
      line-height: 1.65;
      margin-bottom: 12px;
      color: inherit;
      opacity: 0.95;
    }

    .content-block ul {
      padding-left: 20px;
      margin-bottom: 16px;
    }

    .content-block li {
      margin-bottom: 6px;
      font-size: 15px;
    }

    .content-block strong {
      font-weight: 600;
      color: inherit;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;
    const { HashRouter, Switch, Route, useHistory, useLocation } = ReactRouterDOM;
    const { motion, AnimatePresence } = window.Motion;

    // --- DATA ---
    const questions = [
      { id: 1, text: "카페나 식당에 가면 사람들이 서비스를 이용할 때 어디서 멈칫거리는지 나도 모르게 관찰하곤 한다.", archetype: "Anthropologist" },
      { id: 2, text: "회의 내용이 뒤섞여 있으면 \"잠시만요, 지금 무슨 이야기를 하는 중이죠?\"라고 범위를 좁히고 싶다.", archetype: "Cartographer" },
      { id: 3, text: "누가 \"이게 대박이래요\"라고 하면, \"그게 통한다는 구체적인 근거가 있나요?\"라고 확인하고 싶어진다.", archetype: "Scientist" },
      { id: 4, text: "다들 찬성하는 분위기일 때, 구석에서 표정이 안 좋은 사람에게 \"혹시 걱정되는 부분이 있으신가요?\"라고 묻고 싶다.", archetype: "Journalist" },
      { id: 5, text: "새로운 일을 시작할 때, \"이걸 하느라 우리가 포기해야 하는 다른 중요한 일은 없을까?\"를 먼저 계산해본다.", archetype: "Economist" },
      { id: 6, text: "데이터 그래프를 보는 것보다, 그 제품을 쓰는 사람의 표정이나 손짓을 직접 한 번 보는 게 더 믿음직하다.", archetype: "Anthropologist" },
      { id: 7, text: "아이디어가 아무리 좋아도, 우리가 지금 해결할 수 있는 영역 밖의 일이면 과감히 제외해야 마음이 편하다.", archetype: "Cartographer" },
      { id: 8, text: "\"느낌이 좋다\"는 말보다는, 작게라도 직접 테스트해 본 결과가 있어야 다음 단계로 넘어갈 용기가 난다.", archetype: "Scientist" },
      { id: 9, text: "우리를 칭찬하는 말보다는, 우리 서비스에 대해 아주 구체적으로 불만을 말하는 사람의 이야기에 더 귀가 쫑긋한다.", archetype: "Journalist" },
      { id: 10, text: "아무리 멋진 제안이라도 우리 팀의 현재 시간과 에너지를 너무 많이 뺏는다면, 신중하게 거절해야 한다고 생각한다.", archetype: "Economist" },
      { id: 11, text: "사람들이 말로는 \"좋아요\"라고 해도, 실제로 쓸 때 왠지 머뭇거리는 그 순간을 포착할 때 \"진짜 문제\"를 찾았다고 느낀다.", archetype: "Anthropologist" },
      { id: 12, text: "논의가 길어지면 화이트보드에 지금 우리가 이야기하는 주제들을 상자에 담아 구조를 그려보고 싶어진다.", archetype: "Cartographer" },
      { id: 13, text: "내 생각이 틀릴 수도 있다는 것을 인정하고, \"이게 왜 안 될 수도 있지?\"를 미리 따져보는 과정이 즐겁다.", archetype: "Scientist" },
      { id: 14, text: "\"다들 그렇게 생각해요\"라는 말은 믿지 않는다. \"정확히 누가, 어떤 상황에서 그렇게 말했는지\"가 훨씬 중요하다.", archetype: "Journalist" },
      { id: 15, text: "제안을 들으면 \"이걸로 우리가 얻는 이득만큼, 잃게 되는 비용이나 수고는 얼마일까?\"를 냉정하게 따져본다.", archetype: "Economist" },
      { id: 16, text: "일상에서 사람들이 불편함을 참고 억지로 적응해서 쓰는 '이상한 방식'들을 발견하는 게 흥미롭다.", archetype: "Anthropologist" },
      { id: 17, text: "여러가지가 섞인 문제를 보면 우선순위 먼저 정리하고 싶다.", archetype: "Cartographer" },
      { id: 18, text: "처음보는 확신에 찬 주장을 보면 \"주장을 뒷받침할 수 있는 구체적인 숫자나 자료가 있을까\" 생각하고 알아본다.", archetype: "Scientist" },
      { id: 19, text: "똑똑한 한 사람의 의견보다, 여러 사람의 평범하고 생생한 삶의 이야기들이 모였을 때 진짜 문제가 선명해진다고 느낀다.", archetype: "Journalist" },
      { id: 20, text: "좋은 의도의 사업이라도, 현실적으로 예산이 계속 버텨줄 수 있는 구조인지부터 냉정하게 살핀다.", archetype: "Economist" },
      { id: 21, text: "다들 \"이게 원인이야\"라고 할 때, 왠지 설명되지 않는 구석이 하나라도 있으면 끝까지 찝찝함을 느낀다.", archetype: "Detective" },
      { id: 22, text: "문제가 생긴 건 누구 한 명의 잘못이라기보다, 그렇게 행동할 수밖에 없게 만든 '상황의 연결' 때문이라고 생각한다.", archetype: "Systems Thinker" },
      { id: 23, text: "우리가 지금 쓰고 있는 '공정'이나 '성공' 같은 단어들을 팀원 모두가 똑같은 의미로 쓰고 있는지 의심해본다.", archetype: "Philosopher" },
      { id: 24, text: "계획대로 잘 진행될 때조차 \"만약 갑자기 상황이 바뀌면 우리는 어떻게 대처하지?\"라며 플랜 B를 머릿속으로 그린다.", archetype: "Scenario Planner" },
      { id: 25, text: "사람들이 무심코 사용하는 물건이 닳아있는 모양이나 위치를 보고 그들의 진짜 습관을 추측해본다.", archetype: "Anthropologist" },
      { id: 26, text: "남들이 다 아는 정보보다, 아무도 주목하지 않았던 사소한 기록이나 흔적에서 문제의 실마리를 찾으려 한다.", archetype: "Detective" },
      { id: 27, text: "하나를 고치면 다른 곳에서 또 문제가 터지는 상황을 방지하기 위해, 문제들의 '얽히고설킨 관계'를 먼저 그린다.", archetype: "Systems Thinker" },
      { id: 28, text: "\"이건 효율적이야\"라는 말을 들으면 \"그런데 우리에게 '효율'이 왜 그렇게 중요한 가치죠?\"라고 묻고 싶다.", archetype: "Philosopher" },
      { id: 29, text: "해결책이 가져올 좋은 결과보다, 그로 인해 생길지도 모를 예상치 못한 부작용 리스트가 먼저 머릿속에 떠오른다.", archetype: "Scenario Planner" },
      { id: 30, text: "사람들의 답변 내용보다, 그 대답을 할 때의 미세한 망설임이나 눈빛의 변화가 더 많은 것을 말해준다고 믿는다.", archetype: "Anthropologist" },
      { id: 31, text: "사건의 앞뒤가 안 맞을 때 \"왜?\"라고 끈질기게 질문해서, 상대방이 미처 생각지 못한 부분을 깨닫게 하기도 한다.", archetype: "Detective" },
      { id: 32, text: "눈앞의 불을 끄는 것보다, 이 문제가 계속 반복되게 만드는 '보이지 않는 판'이 무엇인지 찾는 데 더 집중한다.", archetype: "Systems Thinker" },
      { id: 33, text: "\"원래 다 이래\"라는 말을 들을 때 가장 답답하며, 당연하다고 생각하는 전제들을 하나씩 무너뜨려 보고 싶다.", archetype: "Philosopher" },
      { id: 34, text: "당장 내일의 성과보다, 이 결정이 1년 뒤 우리 팀에 어떤 영향을 줄지를 생각하면 가끔 밤잠을 설친다.", archetype: "Scenario Planner" },
      { id: 35, text: "서둘러 정답을 내기보다는, 현장을 더 관찰하며 우리가 진짜 풀어야 할 문제가 뭔지 고민하는 시간을 충분히 갖고 싶다.", archetype: "Anthropologist" },
      { id: 36, text: "사건의 흐름을 짚어보며 남들이 놓친 미세한 모순을 찾아냈을 때 기쁨을 느낀다.", archetype: "Detective" },
      { id: 37, text: "한 쪽을 누르면 다른 쪽이 튀어나오는 풍선 효과를 고려해서, 전체적인 균형을 맞추는 고민을 많이 한다.", archetype: "Systems Thinker" },
      { id: 38, text: "당장의 해결책보다 '우리가 문제를 바라보는 방식' 자체가 틀렸을지도 모른다는 의심을 한다.", archetype: "Philosopher" },
      { id: 39, text: "\"상황이 최악으로 흘러간다면 어떤 일이 벌어질까?\"를 시나리오로 그려보는 것이 불안을 줄이는 최고의 방법이라 생각한다.", archetype: "Scenario Planner" },
      { id: 40, text: "사람들의 인터뷰 답변보다 그들이 무의식적으로 사용하는 말버릇이나 물건의 마모 상태를 더 신뢰한다.", archetype: "Anthropologist" },
      { id: 41, text: "인터뷰 내용을 정리할 때 내 의견을 섞지 않고, 상대방이 쓴 독특한 표현이나 단어들을 그대로 살려 기록한다.", archetype: "Journalist" },
      { id: 42, text: "중대한 결정을 내릴 때, \"내가 보고 싶은 것만 보고 있는 건 아닐까?\"라는 생각에 객관적인 데이터를 다시 확인한다.", archetype: "Scientist" },
      { id: 43, text: "낭비되는 시간이나 인력이 없는지 수시로 살피며, 한정된 자원을 가장 효율적으로 배분하고 싶어 한다.", archetype: "Economist" },
      { id: 44, text: "누군가의 불만을 들으면 \"이게 개인적인 감정인지, 아니면 공적으로 해결해야 할 정당한 문제인지\"를 먼저 심사한다.", archetype: "Judge" },
      { id: 45, text: "문제가 터지면 사람을 비난하기보다, 그런 실수가 나올 수밖에 없었던 주변 환경과 구조를 먼저 탓한다.", archetype: "Systems Thinker" },
      { id: 46, text: "상대방이 이야기하다 멈췄을 때, 서둘러 말을 얹기보다 가만히 눈을 맞추며 다음 이야기를 기다려주는 편이다.", archetype: "Journalist" },
      { id: 47, text: "가설을 세울 때 \"우리가 틀렸다는 것을 가장 빠르게 확인할 방법은 뭘까?\"를 고민하며 실패의 가능성을 열어둔다.", archetype: "Scientist" },
      { id: 48, text: "아무리 근사한 비전이라도, 결국 \"그래서 수익이 나는가?\" 혹은 \"지속 가능한가?\"라는 질문에 답하지 못하면 의미가 없다.", archetype: "Economist" },
      { id: 49, text: "해야 할 일들이 산더미 같을 때, 지금 우리 팀이 가진 자원으로 해결할 수 있는 '단 하나의 핵심 문제'를 추려낸다.", archetype: "Judge" },
      { id: 50, text: "특정 부분만 완벽하게 고치는 것보다, 전체 시스템의 흐름이 막히지 않게 조절하는 것이 훨씬 중요하다고 믿는다.", archetype: "Systems Thinker" },
      { id: 51, text: "우리에게 유리한 정보만 수집하기보다는, 우리가 틀렸음을 말해주는 반대 의견을 일부러 찾아다닌다.", archetype: "Journalist" },
      { id: 52, text: "\"제 느낌에는요\"라는 말로 설득하려는 사람을 보면 일단 정보의 신뢰도가 떨어진다고 판단한다.", archetype: "Scientist" },
      { id: 53, text: "아이디어가 아무리 좋아도 실행 과정에서 누군가가 일방적으로 희생한다면 좋은 해결책이 아니라고 본다.", archetype: "Economist" },
      { id: 54, text: "문제 정의가 논리적으로 설득력이 없으면, 아무리 반짝이는 해결책이라도 \"아직 해결할 준비가 안 됐다\"고 선을 긋는다.", archetype: "Judge" },
      { id: 55, text: "복잡하게 얽힌 실타래에서 어디를 건드려야 전체가 풀릴지 그 '급소'를 찾는 과정에 몰입한다.", archetype: "Systems Thinker" },
      { id: 56, text: "사람들의 말 뒤에 숨겨진 '진짜 마음'이나 '간절함'이 무엇인지 파악하려고 깊이 몰입한다.", archetype: "Journalist" },
      { id: 57, text: "결론이 나기 전에 \"그걸 어떻게 확인할 수 있죠? 실제 테스트해봤나요?\"라고 따져 묻는 편이다.", archetype: "Scientist" },
      { id: 58, text: "비효율이 발생하는 상황을 방치하기보다 현실적인 대안을 찾아 자원을 아끼고 싶다.", archetype: "Economist" },
      { id: 59, text: "\"다 중요해 보여요\"라는 팀원들에게 가장 중요한 단 하나를 고르라고 독려하는 편이다.", archetype: "Judge" },
      { id: 60, text: "악순환의 고리를 끊어내기 위해 어디에 힘을 집중해야 할지 구조적으로 접근한다.", archetype: "Systems Thinker" }
    ];

    const archetypes = [
      {
        id: 'Anthropologist',
        name: '인류학자 (The Anthropologist)',
        oneLiner: '침묵 속의 질서를 발굴하는 관찰의 거장',
        coreQuestion: '“사람들은 실제로 어떻게 행동하는가?”',
        desc: '문제의 파편들을 수집하는 단계입니다. 인류학자가 인간의 무의식적 행동(행동 데이터)을 포착하면, 저널리스트가 그 행동 뒤에 숨은 이해관계자들의 목소리(언어 데이터)를 채집합니다.',
        fullContent: `
          <h3>1. 핵심 역량: 가설을 압도하는 ‘맥락적 지능’</h3>
          <p>인류학자의 가장 강력한 무기는 <strong>‘판단하지 않는 응시’</strong>입니다. 대부분의 기획자나 문제 해결사들은 현장에 나가기 전 이미 가설을 세우고, 그 가설을 지지할 증거만을 수집하려는 경향이 있습니다. 하지만 인류학자는 자신의 편견을 의도적으로 삭제합니다.</p>
          <p><strong>언어 너머의 진실</strong>: 사람들은 자신의 욕망을 완벽하게 언어로 표현하지 못합니다. "왜 이 기능을 사용하지 않습니까?"라는 질문에 돌아오는 대답은 대개 논리적으로 꾸며진 사후 변명인 경우가 많습니다. 인류학자는 그 대답을 신뢰하는 대신, 답변자의 미세한 눈떨림, 버튼을 누르기 전의 망설임, 혹은 기존 시스템의 불편함을 견디기 위해 스스로 고안해낸 ‘기괴한 우회로’를 포착합니다.</p>
          
          <h3>2. 팀 내의 역할: 집단적 환각을 깨우는 ‘현실 정박지’</h3>
          <p>팀 프로젝트가 진행될수록 구성원들은 자기들이 만든 논리와 화려한 아이디어에 매몰되어, 그것이 실제 세상과 연결되어 있다는 착각, 즉 '논리적 환각'에 빠지기 쉽습니다. 이때 인류학자는 팀의 발을 지상으로 끌어내리는 결정적인 역할을 수행합니다.</p>
          <p><strong>증거 중심의 제동</strong>: 팀이 공들여 쌓아 올린 가설이 현장의 실제 모습과 충돌할 때, 인류학자는 가차 없이 그 균열을 보고합니다. 이는 팀의 사기를 꺾기 위함이 아니라, 잘못된 방향으로 질주하여 자원을 낭비하는 것을 막으려는 고결한 보호 본능입니다.</p>

          <h3>3. 지적 그림자: 관찰의 함정과 결정의 지연</h3>
          <p>모든 아키타입은 그 강점만큼이나 짙은 그림자를 가집니다. 인류학자가 경계해야 할 지점은 <strong>‘관찰의 무한 루프’</strong>입니다.</p>
          <p><strong>완벽한 데이터에 대한 집착</strong>: 현장은 늘 가변적이며 예외 사례가 존재합니다. 인류학자는 그 예외 하나조차 놓치지 않으려다 보니 결론을 내는 속도가 늦어질 수 있습니다.</p>

          <h3>4. 존재의 가치: 당신이 없으면 팀이 겪게 될 비극</h3>
          <p>인류학자가 없는 팀은 <strong>‘정답 같은 오답’</strong>을 향해 질주합니다. 논리적으로는 완벽하고 기술적으로도 훌륭한 해결책을 내놓고도, 정작 시장에서 "왜 아무도 쓰지 않는가?"라는 질문에 직면하게 됩니다.</p>

          <h3>5. 당신을 위한 제언: 통찰을 행동으로 전환하는 법</h3>
          <p>불완전한 결단의 수용: 때로는 모든 의문이 해소되지 않았더라도, 지금까지 발견한 '가장 확실한 진실'을 바탕으로 팀의 다음 단계에 동참하는 결단력이 필요합니다.</p>
        `,
        blindSpot: '관찰의 무한 루프에 빠져 실행을 지연시킬 수 있음'
      },
      {
        id: 'Journalist',
        name: '저널리스트 (The Journalist)',
        oneLiner: '파편화된 증언을 엮어 문제의 진실을 재구성하는 맥락의 거장',
        coreQuestion: '“누가 이 문제로 인해 가장 큰 영향을 받는가?”',
        desc: '문제를 다양한 이해관계자들이 각자의 욕망과 결핍을 투영하며 만들어낸 \'살아있는 서사\'로 받아들입니다.',
        fullContent: `
          <h3>1. 핵심 역량: 가려진 목소리를 찾아내는 ‘탐사적 경청’</h3>
          <p>저널리스트의 진정한 힘은 단순히 받아적는 것이 아니라, <strong>‘질문의 각도’</strong>를 바꾸는 데 있습니다.</p>
          <p><strong>행간을 읽는 심문</strong>: 사람들은 때로 자신을 보호하기 위해, 혹은 조직의 논리에 따라 정제된 답변만을 내놓습니다. 저널리스트는 언어의 표면 아래 숨겨진 정치적 맥락과 감정적 동기를 읽어냅니다.</p>

          <h3>2. 팀 내의 역할: 집단적 편향을 깨는 ‘서사의 편집자’</h3>
          <p><strong>관점의 민주화</strong>: 특정 부서의 논리가 팀을 지배하려 할 때, 저널리스트는 수집된 다양한 목소리를 근거로 "이것은 개발팀의 문제정의일 뿐, 운영팀의 시각에서는 전혀 다른 문제일 수 있다"는 사실을 환기시킵니다.</p>

          <h3>3. 지적 그림자: 서사의 함정과 중립의 딜레마</h3>
          <p><strong>기록자의 소외</strong>: 너무 많은 목소리를 담으려다 보니, 정작 "그래서 우리의 입장은 무엇인가?"라는 결론 앞에서 망설일 수 있습니다.</p>

          <h3>4. 존재의 가치: 당신이 없으면 팀이 겪게 될 비극</h3>
          <p>저널리스트가 없는 팀은 <strong>‘정치적 맹점’</strong>에 빠집니다. 기술적으로는 훌륭하지만 특정 집단의 반발로 실행조차 못 하는 죽은 해결책을 내놓게 됩니다.</p>

          <h3>5. 당신을 위한 제언: 기록을 통찰로 전환하는 법</h3>
          <p><strong>헤드라인을 먼저 써보기</strong>: 수집한 수많은 목소리를 한 문장으로 압축한다면 무엇이 될지 끊임없이 자문하십시오. 그 헤드라인이 곧 팀이 풀어야 할 <strong>‘문제의 본질’</strong>입니다.</p>
        `,
        blindSpot: '너무 많은 목소리를 담으려다 결론을 내리지 못하는 딜레마'
      },
      {
        id: 'Detective',
        name: '탐정 (The Detective)',
        oneLiner: '현상이라는 알리바이를 깨고 본질적인 원인을 추적하는 인과의 추적자',
        coreQuestion: '“왜 이러한 현상이 반복되는가?”',
        desc: '현상 뒤에 숨겨진 인과관계와 구조적 역학을 분석하여 \'문제의 뿌리\'를 찾아냅니다.',
        fullContent: `
          <h3>1. 핵심 역량: 증상을 원인으로 착각하지 않는 ‘비판적 추론’</h3>
          <p>탐정의 가장 날카로운 무기는 <strong>‘인과 관계의 정밀한 해체’</strong>입니다.</p>
          <p><strong>가짜 문제(Symptom)의 선별</strong>: "매출이 떨어진다"는 현상을 문제 그 자체로 보지 않고 몸이 보내는 '발열' 증상으로 봅니다. 진짜 병명(Root Cause)을 찾을 때까지 추적을 멈추지 않습니다.</p>

          <h3>2. 팀 내의 역할: 헛수고를 방지하는 ‘지적 브레이크’</h3>
          <p><strong>임시방편의 거부</strong>: "이것은 증상을 완화할 뿐, 문제를 해결하지 못한다"는 진단으로 팀이 장기적인 자원 낭비를 하지 않도록 막아줍니다.</p>

          <h3>3. 지적 그림자: 분석의 늪과 냉소주의</h3>
          <p><strong>분석 마비</strong>: 완벽한 인과 관계를 증명하려다 보면 결론을 내리는 데 너무 많은 시간을 소요할 수 있습니다.</p>

          <h3>4. 존재의 가치: 당신이 없으면 팀이 겪게 될 비극</h3>
          <p>탐정이 없는 팀은 <strong>‘두더지 잡기 게임’</strong>을 반복하게 됩니다. 문제를 해결했다고 생각하는 순간, 똑같은 문제가 다른 모습으로 다시 나타납니다. 근본 원인을 제거하지 않았기 때문입니다.</p>
        `,
        blindSpot: '완벽한 인과 증명에 집착하여 실행 타이밍을 놓침'
      },
      {
        id: 'Systems Thinker',
        name: '시스템 사고가 (The Systems Thinker)',
        oneLiner: '보이지 않는 연결 고리를 추적해 문제의 역학 구조를 해체하는 입체적 전략가',
        coreQuestion: '“이 문제는 어떤 구조 속에서 작동하는가?”',
        desc: '문제를 다양한 요소들이 서로 에너지를 주고받으며 유지되는 \'유동적인 생태계\'로 파악합니다.',
        fullContent: `
          <h3>1. 핵심 역량: 선형적 사고를 넘어서는 ‘입체적 통찰’</h3>
          <p>시스템 사고가의 가장 강력한 무기는 <strong>‘피드백 루프의 파악’</strong>입니다. 요소들 사이의 <strong>‘관계’</strong> 자체가 문제의 본질임을 꿰뚫어 봅니다.</p>

          <h3>2. 팀 내의 역할: 재앙을 막는 ‘리스크 시뮬레이터’</h3>
          <p><strong>의도치 않은 결과 예방</strong>: 당장의 근시안적인 성과에 매몰되지 않고 미래의 부작용을 경고합니다.</p>

          <h3>3. 지적 그림자: 과도한 복잡성과 실행의 지연</h3>
          <p><strong>모든 것의 연결성 강조</strong>: "모든 것은 연결되어 있다"는 생각에 매몰되면 어디서부터 손을 대야 할지 모르는 상태에 빠질 수 있습니다.</p>

          <h3>4. 존재의 가치: 당신이 없으면 팀이 겪게 될 비극</h3>
          <p>시스템 사고가가 없는 팀은 <strong>‘악순환의 굴레’</strong>에 갇힙니다. 문제를 해결하기 위해 내놓은 대책이 시간이 지나 더 큰 문제를 야기하는 '코브라 효과'를 경험하게 됩니다.</p>
        `,
        blindSpot: '과도한 복잡성으로 인해 실행 아이디어가 나오지 않음'
      },
      {
        id: 'Cartographer',
        name: '지도제작자 (The Cartographer)',
        oneLiner: '혼돈의 영역에 경계를 긋고 정복 가능한 지형으로 규정하는 전략적 설계자',
        coreQuestion: '“이 문제의 범위와 경계는 어디까지인가?”',
        desc: '문제를 우리가 발을 딛고 있는 \'지형\'으로 인식합니다. 거대한 문제 덩어리를 분석하여 우리가 해결할 수 있는 영역과 없는 영역을 구분해 냅니다.',
        fullContent: `
          <h3>1. 핵심 역량: 모호함을 질서로 바꾸는 ‘구조적 조망’</h3>
          <p>지도제작자의 가장 강력한 무기는 <strong>‘추상적인 문제의 구체적 시각화’</strong>입니다.</p>
          <p><strong>배타적 경계 설정</strong>: "무엇을 할 것인가"보다 <strong>"무엇을 건드리지 않을 것인가"</strong>를 결정하는 데 탁월합니다.</p>

          <h3>2. 팀 내의 역할: 길을 잃지 않게 하는 ‘내비게이터’</h3>
          <p><strong>자원 배분의 가이드</strong>: 팀의 한정된 시간과 비용을 어디에 투입해야 가장 효율적으로 영토를 확보할 수 있을지 전략적 우선순위를 제안합니다.</p>

          <h3>3. 지적 그림자: 경직된 사고와 창의성의 위축</h3>
          <p><strong>지나친 선 긋기</strong>: 정해진 범위 밖에서 나오는 혁신적인 아이디어를 "범위 밖"이라는 이유로 너무 일찍 쳐낼 수 있습니다.</p>

          <h3>4. 존재의 가치: 당신이 없으면 팀이 겪게 될 비극</h3>
          <p>지도제작자가 없는 팀은 <strong>‘정복할 수 없는 에베레스트’</strong> 앞에서 좌절합니다. 문제의 정의가 끝없이 확장되다 보니, 아무리 노력해도 끝이 보이지 않습니다.</p>
        `,
        blindSpot: '경계 밖의 혁신적인 아이디어까지 차단할 위험'
      },
      {
        id: 'Philosopher',
        name: '철학자 (The Philosopher)',
        oneLiner: '당연함의 장막을 걷어내고 문제의 본질적 가치를 심문하는 사유의 개척자',
        coreQuestion: '“이 문제를 가능하게 하는 전제는 무엇인가?”',
        desc: '모두가 정답을 찾을 때 조용히 \'질문\'의 타당성을 검토합니다. 문제정의 과정에 숨어 있는 암묵적인 가정, 편견, 가치 판단을 수면 위로 끌어올립니다.',
        fullContent: `
           <h3>1. 핵심 역량: 전제를 뒤흔드는 ‘비판적 해체’</h3>
           <p>철학자의 가장 강력한 무기는 <strong>‘개념의 명료화와 가정의 파괴’</strong>입니다.</p>
           <p><strong>숨은 전제 드러내기</strong>: 우리가 당연시했던 기준들이 사실은 고정관념일 수 있음을 증명합니다.</p>

           <h3>2. 팀 내의 역할: 집단지성의 ‘브레인 필터’</h3>
           <p><strong>개념적 오류 수정</strong>: 논리적으로는 완벽해 보이지만 철학적으로 빈약한 문제정의를 걸러냅니다.</p>

           <h3>3. 지적 그림자: 추상화의 늪과 소통의 장벽</h3>
           <p><strong>무한 담론의 가능성</strong>: 근본적인 원리만 따지다 보면 "그래서 지금 당장 뭘 해야 하나?"라는 실무적인 질문에 답하기 어려워질 수 있습니다.</p>

           <h3>4. 존재의 가치: 당신이 없으면 팀이 겪게 될 비극</h3>
           <p>철학자가 없는 팀은 <strong>‘훌륭하게 정의된 오답’</strong>을 풉니다. 기술적으로 완벽하고 논리적으로 치밀하지만, 정작 세상에 내놓았을 때 "이게 왜 필요하지?"라는 본질적인 회의론에 부딪히게 됩니다.</p>
        `,
        blindSpot: '사유가 행동으로 이어지지 않고 공허한 말잔치에 머물 위험'
      },
      {
        id: 'Scientist',
        name: '과학자 (The Scientist)',
        oneLiner: '주관적 확신을 객관적 실증으로 번역하는 데이터의 수호자',
        coreQuestion: '“이 주장은 무엇으로 검증되는가?”',
        desc: '문제정의란 아직 증명되지 않은 가설일 뿐이며, 이를 관찰 가능한 데이터와 통계로 검증 가능한 상태로 만드는 것이 숙명입니다.',
        fullContent: `
          <h3>1. 핵심 역량: 주장과 사실을 분리하는 ‘엄격한 객관성’</h3>
          <p>과학자의 가장 강력한 무기는 <strong>‘검증 가능성’</strong>에 대한 집착입니다. "내 생각에는"이라는 주장을 가장 경계합니다.</p>

          <h3>2. 팀 내의 역할: 집단적 낙관주의를 식히는 ‘현실의 닻’</h3>
          <p><strong>근거 기반의 제동</strong>: "우리의 느낌"이 아닌 "데이터의 흐름"을 제시하며 잘못된 방향으로의 질주를 막습니다.</p>

          <h3>3. 지적 그림자: 데이터 만능주의와 속도의 저하</h3>
          <p><strong>완벽한 데이터에 대한 갈증</strong>: 모든 것이 데이터로 증명되어야 움직이려다 보니, 데이터가 부족한 신규 영역에서는 결정을 내리지 못할 수 있습니다.</p>

          <h3>4. 존재의 가치: 당신이 없으면 팀이 겪게 될 비극</h3>
          <p>과학자가 없는 팀은 <strong>‘신앙 기반의 프로젝트’</strong>를 수행합니다. 근거 없는 확신으로 시작해, 결과가 나쁠 때는 "운이 없었다"고 치부합니다.</p>
        `,
        blindSpot: '데이터가 모일 때까지 결정을 미루다 시기를 놓침'
      },
      {
        id: 'Economist',
        name: '경제학자 (The Economist)',
        oneLiner: '한정된 자원의 가치를 극대화하고 선택의 대가를 산출하는 현실의 균형추',
        coreQuestion: '“이 문제에는 어떤 비용과 대가가 수반되는가?”',
        desc: '문제정의를 \'어떤 가치를 위해 무엇을 지불할 것인가\'를 결정하는 자원 배분의 문제로 봅니다.',
        fullContent: `
          <h3>1. 핵심 역량: 손익을 넘어선 ‘트레이드오프’ 분석</h3>
          <p>경제학자의 가장 강력한 무기는 <strong>‘기회비용의 가시화’</strong>입니다. "A를 해결하기 위해 우리는 무엇을 포기했는가?"를 끊임없이 묻습니다.</p>

          <h3>2. 팀 내의 역할: 지속 가능성을 담보하는 ‘전략적 필터’</h3>
          <p><strong>비현실적 정의의 차단</strong>: 경제적으로 타산이 맞지 않거나 조직의 역량을 초과하는 문제정의를 걸러냅니다.</p>

          <h3>3. 지적 그림자: 숫자의 함정과 가치의 협소화</h3>
          <p><strong>계량화할 수 없는 가치의 경시</strong>: 감동, 신뢰, 유대감 등 숫자로 즉각 환산되지 않는 가치를 '비효율'로 치부할 위험이 있습니다.</p>

          <h3>4. 존재의 가치: 당신이 없으면 팀이 겪게 될 비극</h3>
          <p>경제학자가 없는 팀은 <strong>‘우아한 파산’</strong>을 맞이합니다. 정의된 문제는 훌륭하지만, 정작 그것을 유지할 자원이 고갈되어 사장됩니다.</p>
        `,
        blindSpot: '숫자로 환산되지 않는 정성적 가치를 무시할 수 있음'
      },
      {
        id: 'Scenario Planner',
        name: '시나리오 플래너 (The Scenario Planner)',
        oneLiner: '현재의 개입이 불러올 미래의 파동을 예측하는 시간의 설계자',
        coreQuestion: '“개입 이후에는 어떤 결과가 발생할 수 있는가?”',
        desc: '문제를 시간의 흐름에 따라 변모하는 \'역동적인 과정\'으로 이해합니다.',
        fullContent: `
          <h3>1. 핵심 역량: 나비효과를 읽어내는 ‘미래 예측적 통찰’</h3>
          <p>시나리오 플래너의 가장 강력한 무기는 <strong>‘다중 시나리오 설계’</strong>입니다. 1차 결과 뒤에 숨은 2차, 3차 파생 효과를 읽어냅니다.</p>

          <h3>2. 팀 내의 역할: 근시안적 사고를 깨는 ‘미래의 수호자’</h3>
          <p><strong>부작용의 선제적 방어</strong>: "지금 이렇게 하면 나중에 이런 문제가 생긴다"는 경고를 통해 더 책임감 있는 결정을 유도합니다.</p>

          <h3>3. 지적 그림자: 기우와 실행의 주저</h3>
          <p><strong>지나친 걱정</strong>: 발생 확률이 낮은 부정적 시나리오에 과도하게 몰입하면, 꼭 필요한 도전조차 "위험하다"며 가로막을 수 있습니다.</p>

          <h3>4. 존재의 가치: 당신이 없으면 팀이 겪게 될 비극</h3>
          <p>시나리오 플래너가 없는 팀은 <strong>‘단기 승리 후 장기 패배’</strong>의 늪에 빠집니다. 오늘의 해결책이 내일의 괴물이 되어 돌아옵니다.</p>
        `,
        blindSpot: '부정적 시나리오에 몰입해 도전을 주저함'
      },
      {
        id: 'Judge',
        name: '판사 (The Judge)',
        oneLiner: '문제의 본질적 가치와 개입의 정당성을 선언하는 최후의 보루',
        coreQuestion: '“이것은 우리가 개입해야 할 문제인가?”',
        desc: '이 문제가 공적인 가치가 있는지, 우리가 해결할 자격과 책임이 있는지 냉정하게 판결합니다.',
        fullContent: `
          <h3>1. 핵심 역량: 문제의 격을 결정하는 ‘정당성 심사’</h3>
          <p>판사의 가장 강력한 무기는 <strong>‘분별력과 결단력’</strong>입니다. 단순한 불편함(Complaint)과 진짜 문제(Problem)를 엄격히 구분합니다.</p>

          <h3>2. 팀 내의 역할: 불필요한 질주를 멈추는 ‘최종 게이트키퍼’</h3>
          <p><strong>우선순위의 최종 확정</strong>: "우리가 이번에 집중할 문제는 이것이다"라고 선언하여 팀에게 확신을 줍니다.</p>

          <h3>3. 지적 그림자: 독단적 판결과 공감의 결여</h3>
          <p><strong>권위주의적 태도</strong>: "그건 문제가 아니다"라는 단정적인 태도는 팀원들의 자발적인 발견 의지를 꺾을 수 있습니다.</p>

          <h3>4. 존재의 가치: 당신이 없으면 팀이 겪게 될 비극</h3>
          <p>판사가 없는 팀은 <strong>‘모두의 요구에 휘둘리는 난파선’</strong>이 됩니다. 논리적으로는 완벽할지 모르나 명분 싸움에서 패배하게 됩니다.</p>
        `,
        blindSpot: '권위적인 태도로 팀의 창의적 소통을 막을 수 있음'
      }
    ];

    const calculateResults = (answers) => {
      const scores = {};
      questions.forEach(q => {
        if (!scores[q.archetype]) scores[q.archetype] = 0;
      });
      Object.entries(answers).forEach(([qId, value]) => {
        const q = questions.find(q => q.id === Number(qId));
        if (q) scores[q.archetype] += value;
      });
      const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
      return {
        primary: sorted[0] ? sorted[0][0] : null,
        secondary: sorted[1] ? sorted[1][0] : null,
        underUsed: sorted[sorted.length - 1] ? sorted[sorted.length - 1][0] : null,
        allScores: sorted
      };
    };

    // --- COMPONENTS ---
    const LandingPage = () => {
      const history = useHistory();
      return (
        <div className="screen" style={{ justifyContent: 'center', background: 'linear-gradient(135deg, #f5f7fa 0%, #ffffff 100%)' }}>
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.8, ease: "easeOut" }}
            style={{ textAlign: 'center' }}
          >
            <motion.div
              initial={{ scale: 0.9 }}
              animate={{ scale: 1 }}
              transition={{ duration: 1, ease: "easeOut" }}
              style={{
                width: '80px',
                height: '80px',
                margin: '0 auto 32px',
                background: 'linear-gradient(135deg, var(--color-accent) 0%, #5a8fb8 100%)',
                borderRadius: '20px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                boxShadow: '0 10px 30px rgba(69, 123, 157, 0.3)'
              }}
            >
              <span style={{ fontSize: '40px' }}>🧭</span>
            </motion.div>

            <h1 className="text-h1" style={{ marginBottom: '24px', fontSize: '28px', lineHeight: '1.4' }}>
              문제를 푸는 능력보다,<br />
              <span style={{ color: 'var(--color-accent)', fontWeight: 700 }}>문제를 정의하는 방식</span>이<br />
              결과를 바꿉니다.
            </h1>

            <div style={{ marginBottom: '40px', background: 'rgba(255,255,255,0.8)', padding: '24px', borderRadius: '12px', backdropFilter: 'blur(10px)' }}>
              <p className="text-body" style={{ marginBottom: '16px', fontSize: '16px' }}>
                이 테스트는 당신이 문제에 직면했을 때<br />
                <strong style={{ color: 'var(--color-accent)' }}>가장 먼저 꺼내 드는 사고 도구</strong>를 진단합니다.
              </p>
              <div style={{ display: 'flex', gap: '12px', justifyContent: 'center', flexWrap: 'wrap', marginTop: '20px' }}>
                <span style={{ padding: '6px 16px', background: '#f0f4f8', borderRadius: '20px', fontSize: '13px', color: '#555' }}>⏱️ 소요시간 5분</span>
                <span style={{ padding: '6px 16px', background: '#f0f4f8', borderRadius: '20px', fontSize: '13px', color: '#555' }}>📊 60개 문항</span>
                <span style={{ padding: '6px 16px', background: '#f0f4f8', borderRadius: '20px', fontSize: '13px', color: '#555' }}>🎯 10가지 유형</span>
              </div>
            </div>

            <button
              onClick={() => history.push('/intro')}
              style={{
                width: '100%',
                padding: '20px',
                background: 'linear-gradient(135deg, var(--color-accent) 0%, #5a8fb8 100%)',
                color: '#fff',
                borderRadius: '12px',
                fontSize: '17px',
                fontWeight: 600,
                letterSpacing: '-0.01em',
                transition: 'transform 0.2s, box-shadow 0.2s',
                boxShadow: '0 4px 15px rgba(69, 123, 157, 0.3)',
                border: 'none',
                cursor: 'pointer'
              }}
              onMouseEnter={(e) => { e.currentTarget.style.transform = 'translateY(-2px)'; e.currentTarget.style.boxShadow = '0 6px 20px rgba(69, 123, 157, 0.4)'; }}
              onMouseLeave={(e) => { e.currentTarget.style.transform = 'none'; e.currentTarget.style.boxShadow = '0 4px 15px rgba(69, 123, 157, 0.3)'; }}
            >
              🚀 테스트 시작하기
            </button>
          </motion.div>
        </div>
      );
    };

    const IntroPage = () => {
      const history = useHistory();
      return (
        <div className="screen" style={{ background: 'linear-gradient(135deg, #f5f7fa 0%, #ffffff 100%)' }}>
          <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.6 }}>
            <div style={{ height: '20px' }}></div>
            <h2 className="text-h2" style={{ textAlign: 'center', marginBottom: '32px', fontSize: '24px' }}>시작하기 전에 📋</h2>

            <div style={{ background: 'linear-gradient(135deg, #eef2f7 0%, #ffffff 100%)', padding: '28px', borderRadius: '16px', marginBottom: '24px', border: '1px solid #e0e7ef', boxShadow: '0 4px 12px rgba(0,0,0,0.05)' }}>
              <div style={{ display: 'flex', alignItems: 'center', marginBottom: '20px' }}>
                <div style={{ width: '40px', height: '40px', borderRadius: '50%', background: 'var(--color-accent)', display: 'flex', alignItems: 'center', justifyContent: 'center', marginRight: '12px' }}>
                  <span style={{ fontSize: '20px' }}>✍️</span>
                </div>
                <p style={{ fontWeight: 700, fontSize: '17px', margin: 0, color: '#222' }}>참여 가이드</p>
              </div>
              <ul style={{ paddingLeft: '0', listStyle: 'none', lineHeight: '2' }}>
                <li style={{ display: 'flex', alignItems: 'flex-start', marginBottom: '12px' }}>
                  <span style={{ fontSize: '20px', marginRight: '12px' }}>⚡</span>
                  <span className="text-body">생각을 멈추지 말고 <strong style={{ color: 'var(--color-accent)' }}>직관적</strong>으로 답하세요</span>
                </li>
                <li style={{ display: 'flex', alignItems: 'flex-start', marginBottom: '12px' }}>
                  <span style={{ fontSize: '20px', marginRight: '12px' }}>💼</span>
                  <span className="text-body">구체적인 <strong style={{ color: 'var(--color-accent)' }}>최근 프로젝트</strong>를 떠올리세요</span>
                </li>
                <li style={{ display: 'flex', alignItems: 'flex-start' }}>
                  <span style={{ fontSize: '20px', marginRight: '12px' }}>🎯</span>
                  <span className="text-body">'이상적인 모습'이 아닌 <strong style={{ color: 'var(--color-accent)' }}>'실제 모습'</strong>에 체크하세요</span>
                </li>
              </ul>
            </div>

            <div style={{ background: '#fff9e6', padding: '16px', borderRadius: '12px', marginBottom: '32px', border: '1px solid #ffe4a3' }}>
              <p style={{ fontSize: '14px', margin: 0, color: '#856404', lineHeight: '1.6' }}>
                💡 <strong>Tip:</strong> 정답은 없습니다. 평소 당신의 모습을 솔직하게 표현해주세요.
              </p>
            </div>

            <button
              onClick={() => history.push('/test')}
              style={{
                width: '100%',
                padding: '20px',
                background: 'linear-gradient(135deg, var(--color-accent) 0%, #5a8fb8 100%)',
                color: '#fff',
                borderRadius: '12px',
                fontWeight: 600,
                fontSize: '17px',
                border: 'none',
                cursor: 'pointer',
                boxShadow: '0 4px 15px rgba(69, 123, 157, 0.3)',
                transition: 'transform 0.2s'
              }}
              onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-2px)'}
              onMouseLeave={(e) => e.currentTarget.style.transform = 'none'}
            >
              🚀 테스트 진행하기
            </button>
          </motion.div>
        </div>
      );
    };

    const TestPage = () => {
      const history = useHistory();
      const [index, setIndex] = useState(() => {
        const saved = localStorage.getItem('archetype_progress');
        return saved ? JSON.parse(saved).index : 0;
      });
      const [answers, setAnswers] = useState(() => {
        const saved = localStorage.getItem('archetype_progress');
        return saved ? JSON.parse(saved).answers : {};
      });
      const [isFinishing, setIsFinishing] = useState(false);

      // Save progress whenever it changes
      useEffect(() => {
        if (!isFinishing) {
          localStorage.setItem('archetype_progress', JSON.stringify({ index, answers }));
        }
      }, [index, answers, isFinishing]);

      const currentQuestion = questions[index] || questions[0];
      const progress = ((index) / questions.length) * 100;

      const handleAnswer = (val) => {
        const newAnswers = { ...answers, [currentQuestion.id]: val };
        setAnswers(newAnswers);

        // Wait for animation
        setTimeout(() => {
          if (index < questions.length - 1) {
            setIndex(prev => prev + 1);
          } else {
            finishTest(newAnswers);
          }
        }, 300);
      };

      const finishTest = (finalAnswers) => {
        setIsFinishing(true);
        setTimeout(() => {
          localStorage.setItem('archetype_answers', JSON.stringify(finalAnswers));
          localStorage.removeItem('archetype_progress'); // Clear progress after completion
          history.push('/result');
        }, 2000);
      };

      if (isFinishing) return (
        <div className="screen" style={{ justifyContent: 'center', alignItems: 'center' }}>
          <p className="text-body" style={{ opacity: 0.6 }}>결과를 분석하고 있습니다...</p>
        </div>
      );

      return (
        <div className="screen" style={{ display: 'flex', flexDirection: 'column' }}>
          <div style={{ width: '100%', height: '6px', background: '#f0f0f0', marginBottom: '32px', marginTop: '16px', borderRadius: '3px', overflow: 'hidden' }}>
            <motion.div
              style={{ height: '100%', background: 'linear-gradient(90deg, var(--color-accent) 0%, #5a8fb8 100%)' }}
              initial={{ width: 0 }}
              animate={{ width: `${progress}%` }}
              transition={{ duration: 0.3 }}
            />
          </div>
          <div style={{ position: 'relative', flex: 1, width: '100%' }}>
            <AnimatePresence>
              <motion.div
                key={index}
                initial={{ opacity: 0, x: 20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -20 }}
                transition={{ duration: 0.3 }}
                style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  width: '100%',
                  height: '100%',
                  display: 'flex',
                  flexDirection: 'column',
                  backgroundColor: 'var(--color-surface)'
                }}
              >
                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', justifyContent: 'center', padding: '0 0 40px 0' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '24px' }}>
                    <div>
                      <span className="text-small" style={{ color: 'var(--color-accent)', marginBottom: '8px', display: 'block', fontWeight: 600 }}>QUESTION {index + 1} / {questions.length}</span>
                      <div style={{ width: '60px', height: '3px', background: 'linear-gradient(90deg, var(--color-accent) 0%, #5a8fb8 100%)', borderRadius: '2px' }}></div>
                    </div>
                    {index > 0 && (
                      <button
                        onClick={() => setIndex(prev => prev - 1)}
                        style={{
                          background: '#f0f0f0',
                          border: 'none',
                          color: '#666',
                          fontSize: '12px',
                          fontWeight: 600,
                          cursor: 'pointer',
                          padding: '6px 12px',
                          borderRadius: '20px',
                          display: 'flex',
                          alignItems: 'center',
                          gap: '4px',
                          transition: 'background 0.2s'
                        }}
                        onMouseEnter={(e) => e.currentTarget.style.background = '#e0e0e0'}
                        onMouseLeave={(e) => e.currentTarget.style.background = '#f0f0f0'}
                      >
                        ← 이전
                      </button>
                    )}
                  </div>
                  <h2 className="text-h1" style={{ fontSize: '20px', lineHeight: '1.6', marginBottom: '0' }}>{currentQuestion.text}</h2>
                </div>
                <div style={{ marginBottom: '20px', background: '#f8f9fa', padding: '24px', borderRadius: '12px' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '16px' }}>
                    {[1, 2, 3, 4, 5].map((val) => (
                      <button
                        key={val}
                        onClick={() => handleAnswer(val)}
                        style={{
                          width: '52px',
                          height: '52px',
                          borderRadius: '50%',
                          background: '#fff',
                          border: '2px solid #e0e0e0',
                          boxShadow: '0 2px 8px rgba(0,0,0,0.08)',
                          cursor: 'pointer',
                          transition: 'all 0.2s',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center'
                        }}
                        onMouseEnter={(e) => { e.currentTarget.style.transform = 'scale(1.1)'; e.currentTarget.style.borderColor = 'var(--color-accent)'; }}
                        onMouseLeave={(e) => { e.currentTarget.style.transform = 'scale(1)'; e.currentTarget.style.borderColor = '#e0e0e0'; }}
                      >
                        <div style={{
                          width: val === 1 || val === 5 ? '16px' : val === 2 || val === 4 ? '12px' : '8px',
                          height: val === 1 || val === 5 ? '16px' : val === 2 || val === 4 ? '12px' : '8px',
                          background: val === 5 ? '#888' : val === 1 ? '#ccc' : '#ddd',
                          borderRadius: '50%'
                        }}></div>
                      </button>
                    ))}
                  </div>
                  <div style={{ display: 'flex', justifyContent: 'space-between', paddingTop: '8px' }}>
                    <span className="text-small" style={{ color: '#666', fontSize: '13px' }}>전혀 아니다</span>
                    <span className="text-small" style={{ color: '#666', fontSize: '13px' }}>매우 그렇다</span>
                  </div>
                </div>
              </motion.div>
            </AnimatePresence>
          </div>
        </div>
      );
    };

    const RadarChart = ({ data, size = 300 }) => {
      // Safety Check
      if (!data || data.length === 0) return null;

      const radius = size / 2;
      const center = size / 2;
      const angleStep = (Math.PI * 2) / data.length;

      const maxScore = Math.max(...data.map(d => d[1]));
      // Prevent division by zero if maxScore is 0
      const safeMaxScore = maxScore > 0 ? maxScore : 1;
      const scaleFactor = (radius - 60) / safeMaxScore;

      const points = data.map(([id, score], i) => {
        const angle = i * angleStep - Math.PI / 2;
        const r = score * scaleFactor;
        return [
          center + r * Math.cos(angle),
          center + r * Math.sin(angle)
        ];
      }).join(' ');

      const outerPoints = data.map((_, i) => {
        const angle = i * angleStep - Math.PI / 2;
        const r = radius - 60;
        return [
          center + r * Math.cos(angle),
          center + r * Math.sin(angle)
        ];
      });

      return (
        <div style={{ display: 'flex', justifyContent: 'center', margin: '40px 0' }}>
          <svg width={size} height={size} style={{ overflow: 'visible' }}>
            {/* Background Grid (Pentagons/Decagons) */}
            {[0.2, 0.4, 0.6, 0.8, 1].map(scale => (
              <polygon
                key={scale}
                points={outerPoints.map(([x, y]) => {
                  const dx = x - center; const dy = y - center;
                  return `${center + dx * scale},${center + dy * scale}`;
                }).join(' ')}
                fill="none"
                stroke="#eee"
                strokeWidth="1"
              />
            ))}

            {/* Axes */}
            {outerPoints.map(([x, y], i) => (
              <line key={i} x1={center} y1={center} x2={x} y2={y} stroke="#eee" strokeWidth="1" />
            ))}

            {/* Data Area */}
            <polygon points={points} fill="rgba(69, 123, 157, 0.2)" stroke="var(--color-accent)" strokeWidth="2" />

            {/* Data Points */}
            {points.split(' ').map((p, i) => {
              const [x, y] = p.split(',');
              return <circle key={i} cx={x} cy={y} r="3" fill="var(--color-accent)" />
            })}

            {/* Labels */}
            {data.map(([id, score], i) => {
              const angle = i * angleStep - Math.PI / 2;
              const r = radius - 30; // Push labels out
              const x = center + r * Math.cos(angle);
              const y = center + r * Math.sin(angle);
              const arch = archetypes.find(a => a.id === id);
              return (
                <text
                  key={id}
                  x={x}
                  y={y}
                  textAnchor="middle"
                  dominantBaseline="middle"
                  fill="#666"
                  fontSize="11"
                  fontWeight="600"
                >
                  {arch.name.split(' (')[0]}
                </text>
              );
            })}
          </svg>
        </div>
      );
    };

    const ResultCard = ({ archetype, label, subLabel, delay, highlight, isUnderUsed }) => {
      const [expanded, setExpanded] = useState(false);
      if (!archetype) return null;
      return (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay, duration: 0.6 }}
          style={{ background: highlight ? 'var(--color-accent)' : 'var(--color-card-bg)', color: highlight ? '#fff' : 'inherit', padding: '24px', borderRadius: '4px', marginBottom: '16px', cursor: 'pointer', borderLeft: isUnderUsed ? '4px solid #999' : 'none' }}
          onClick={() => setExpanded(!expanded)}
        >
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
            <div>
              <span className="text-small" style={{ textTransform: 'uppercase', color: highlight ? 'rgba(255,255,255,0.7)' : '#888' }}>{label}</span>
              <h3 className="text-h2" style={{ marginTop: '8px', fontSize: '24px' }}>{archetype.name.split(' (')[0]}</h3>
              <p style={{ opacity: 0.9, fontSize: '15px' }}>{archetype.oneLiner}</p>
            </div>
            <div>{expanded ? '−' : '+'}</div>
          </div>
          <AnimatePresence>
            {expanded && (
              <motion.div initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} style={{ overflow: 'hidden' }}>
                <div style={{ paddingTop: '24px', marginTop: '24px', borderTop: highlight ? '1px solid rgba(255,255,255,0.2)' : '1px solid #eee' }}>
                  <div style={{ marginBottom: '24px' }}>
                    <p style={{ fontSize: '15px', lineHeight: '1.6' }}>{archetype.desc}</p>
                  </div>

                  {/* Full Content Block injected via HTML */}
                  <div className="content-block" dangerouslySetInnerHTML={{ __html: archetype.fullContent }} style={{ color: highlight ? 'rgba(255,255,255,0.95)' : 'inherit' }} />

                  <div style={{ background: highlight ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.05)', padding: '16px', borderRadius: '4px', marginTop: '24px' }}>
                    <strong style={{ display: 'block', marginBottom: '8px', color: highlight ? '#fff' : 'var(--color-accent)' }}>⚠️ Blind Spot</strong>
                    <p style={{ fontSize: '14px', margin: 0, color: highlight ? 'rgba(255,255,255,0.9)' : '#555' }}>{archetype.blindSpot}</p>
                  </div>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </motion.div>
      );
    }

    const ResultPage = () => {
      const history = useHistory();
      const [results, setResults] = useState(null);
      useEffect(() => {
        const saved = localStorage.getItem('archetype_answers');
        if (saved) {
          setResults(calculateResults(JSON.parse(saved)));
        }
      }, []);

      if (!results) return (
        <div className="screen" style={{ justifyContent: 'center', alignItems: 'center' }}>
          <p className="text-body" style={{ opacity: 0.6 }}>결과를 찾을 수 없습니다.</p>
          <button className="btn-secondary" onClick={() => window.location.hash = '#/'} style={{ marginTop: '20px' }}>홈으로 돌아가기</button>
        </div>
      );

      const primary = archetypes.find(a => a.id === results.primary);
      const secondary = archetypes.find(a => a.id === results.secondary);
      const underUsed = archetypes.find(a => a.id === results.underUsed);

      return (
        <div className="screen">
          <h2 className="text-h1">진단 결과</h2>
          <p className="text-body" style={{ marginBottom: '40px' }}>이 결과는 고정된 성향이 아니라<br />지금 이 시점에서 자주 호출된 사고 방식입니다.</p>

          <h3 className="text-h2" style={{ marginTop: '0px', marginBottom: '16px' }}>주요 아키타입</h3>
          <ResultCard archetype={primary} label="PRIMARY ARCHETYPE" subLabel="가장 먼저 호출되는 사고" delay={0.2} highlight />
          {/* Secondary Removed as per user request */}
          {/* <ResultCard archetype={secondary} label="Secondary Archetype" subLabel="보조적으로 활용하는 사고" delay={0.4} /> */}

          <h3 className="text-h2" style={{ marginTop: '40px', marginBottom: '16px' }}>그림자 아키타입</h3>
          <ResultCard archetype={underUsed} label="Under-used Archetype" subLabel="다시 돌아봐야 할 질문" delay={0.6} isUnderUsed />

          <div style={{ marginTop: '50px' }}>
            <AnalysisSection primary={primary} secondary={secondary} underUsed={underUsed} allScores={results.allScores} />
          </div>

          <div style={{ marginTop: '60px' }}>
            <h3 className="text-h2">전체 사고 분포</h3>
            <RadarChart data={results.allScores} />

            <div style={{ marginTop: '40px', textAlign: 'center' }}>
              <button
                onClick={() => history.push('/explore')}
                className="btn-secondary"
                style={{ display: 'inline-block', width: 'auto', padding: '12px 24px', cursor: 'pointer' }}
              >
                다른 아키타입 전체 보기
              </button>
            </div>
          </div>
        </div>
      );
    }

    // Inject marked.js for Markdown parsing
    const script = document.createElement('script');
    script.src = "https://cdn.jsdelivr.net/npm/marked/marked.min.js";
    document.head.appendChild(script);

    const AnalysisSection = ({ primary, secondary, underUsed, allScores }) => {
      const [status, setStatus] = useState('idle'); // idle, analyzing, done
      const [analysis, setAnalysis] = useState(null);

      const generateAnalysis = async () => {
        setStatus('analyzing');

        try {
          const response = await fetch('/api/analyze', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              primaryId: primary.id,
              secondaryId: secondary.id,
              underUsedIds: [underUsed.id],
              scores: allScores
            })
          });

          if (!response.ok) throw new Error('API request failed');

          const data = await response.json();
          // Use marked.js if available, else fallback to raw text
          const htmlContent = window.marked ? window.marked.parse(data.analysis) : data.analysis;
          setAnalysis(htmlContent);
          setStatus('done');
        } catch (error) {
          console.error('AI Analysis Error:', error);
          // Fallback to rule-based analysis if AI fails
          const fallback = generateInterpretation(primary, secondary, underUsed);
          setAnalysis(fallback);
          setStatus('done');
        }
      };

      if (status === 'idle') {
        return (
          <div style={{ background: '#EBEFFE', padding: '24px', borderRadius: '8px', textAlign: 'center' }}>
            <h3 className="text-h3" style={{ color: 'var(--color-accent)' }}>✨ AI 맞춤형 종합 해석</h3>
            <p className="text-small" style={{ marginBottom: '16px', color: '#555' }}>
              당신의 성향 조합을 분석하여<br />강점과 보완점을 통합적으로 해석해 드립니다.
            </p>
            <button
              onClick={generateAnalysis}
              style={{
                background: 'var(--color-accent)', color: '#fff', padding: '12px 24px',
                borderRadius: '4px', fontWeight: 600, fontSize: '14px', border: 'none', cursor: 'pointer'
              }}
            >
              종합 결과 생성하기
            </button>
          </div>
        );
      }

      if (status === 'analyzing') {
        return (
          <div style={{ background: '#F5F5F7', padding: '40px 20px', borderRadius: '8px', textAlign: 'center' }}>
            <div className="spinner"></div>
            <p className="text-small" style={{ marginTop: '16px', color: '#666' }}>
              AI가 당신의 문제 해결 DNA를 심층 분석하고 있습니다...<br />
              <span style={{ fontSize: '12px', color: '#999' }}>Gemini Pro 알고리즘 가동 중 (Vercel Secure Gate)</span>
            </p>
            <style>{`
              .spinner {
                width: 24px; height: 24px;
                border: 3px solid #ddd; border-top-color: var(--color-accent);
                borderRadius: 50%; margin: 0 auto;
                animation: spin 1s linear infinite;
              }
              @keyframes spin { to { transform: rotate(360deg); } }
            `}</style>
          </div>
        );
      }

      return (
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          style={{ background: '#fff', border: '1px solid #111', padding: '24px', borderRadius: '8px', position: 'relative', boxShadow: '0 4px 20px rgba(0,0,0,0.08)' }}
        >
          <div style={{ position: 'absolute', top: -12, left: 24, background: '#111', color: '#fff', padding: '4px 12px', fontSize: '12px', fontWeight: 700, borderRadius: '12px' }}>
            AI REPORT (SECURE)
          </div>
          <h3 className="text-h2" style={{ marginTop: '16px' }}>AI 종합 분석 결과</h3>
          <div className="analysis-content" style={{ fontSize: '15px', lineHeight: '1.7', marginTop: '16px' }} dangerouslySetInnerHTML={{ __html: analysis }}></div>
          <style>{`
            .analysis-content h1, .analysis-content h2, .analysis-content h3 { margin-top: 20px; font-size: 18px; color: var(--color-accent); }
            .analysis-content ul, .analysis-content ol { padding-left: 20px; margin: 12px 0; }
            .analysis-content p { margin-bottom: 12px; }
            .analysis-content strong { color: #111; }
          `}</style>
        </motion.div>
      );
    };

    const ExplorePage = () => {
      const history = useHistory();
      const [selectedId, setSelectedId] = useState(null);

      const archetypeIcons = {
        'Anthropologist': '🔍',
        'Journalist': '📰',
        'Detective': '🕵️',
        'Systems Thinker': '🌐',
        'Cartographer': '🗺️',
        'Philosopher': '💭',
        'Scientist': '🔬',
        'Economist': '💰',
        'Scenario Planner': '🎯',
        'Judge': '⚖️'
      };

      const renderList = () => (
        <div style={{ padding: '20px 0 40px 0', background: 'linear-gradient(135deg, #f5f7fa 0%, #ffffff 100%)', minHeight: '100vh' }}>
          <div style={{ textAlign: 'center', marginBottom: '40px' }}>
            <h2 className="text-h2" style={{ fontSize: '26px', marginBottom: '12px' }}>모든 아키타입 탐색</h2>
            <p className="text-body" style={{ color: '#666', fontSize: '15px' }}>10가지 문제정의 사고방식을 탐색해보세요</p>
          </div>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))', gap: '20px' }}>
            {archetypes.map(a => (
              <motion.div
                key={a.id}
                onClick={() => setSelectedId(a.id)}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                whileHover={{ y: -4 }}
                style={{
                  padding: '24px',
                  background: '#fff',
                  borderRadius: '16px',
                  border: '1px solid #e8e8e8',
                  cursor: 'pointer',
                  transition: 'all 0.3s',
                  boxShadow: '0 2px 8px rgba(0,0,0,0.04)'
                }}
                onMouseEnter={(e) => { e.currentTarget.style.boxShadow = '0 8px 24px rgba(0,0,0,0.12)'; e.currentTarget.style.borderColor = 'var(--color-accent)'; }}
                onMouseLeave={(e) => { e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.04)'; e.currentTarget.style.borderColor = '#e8e8e8'; }}
              >
                <div style={{ fontSize: '36px', marginBottom: '16px', textAlign: 'center' }}>{archetypeIcons[a.id] || '📌'}</div>
                <div style={{ fontSize: '18px', fontWeight: 700, color: '#111', marginBottom: '12px', textAlign: 'center' }}>{a.name.split(' (')[0]}</div>
                <div style={{ fontSize: '14px', color: '#666', lineHeight: 1.5, textAlign: 'center' }}>{a.oneLiner}</div>
              </motion.div>
            ))}
          </div>
          <button
            className="btn-secondary"
            style={{
              marginTop: '48px',
              width: '100%',
              maxWidth: '400px',
              margin: '48px auto 0',
              display: 'block',
              padding: '16px',
              borderRadius: '12px'
            }}
            onClick={() => history.goBack()}
          >
            ← 내 결과로 돌아가기
          </button>
        </div>
      );

      const renderDetail = () => {
        const arch = archetypes.find(a => a.id === selectedId);
        return (
          <motion.div
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: -20 }}
            style={{ paddingBottom: '40px' }}
          >
            <button
              onClick={() => setSelectedId(null)}
              style={{ background: 'none', border: 'none', fontSize: '14px', color: '#666', cursor: 'pointer', marginBottom: '16px', display: 'flex', alignItems: 'center' }}
            >
              ← 목록으로
            </button>
            <h2 className="text-h1" style={{ marginBottom: '8px', color: 'var(--color-accent)' }}>{arch.name}</h2>
            <p className="text-h3" style={{ marginBottom: '32px', color: '#555' }}>{arch.oneLiner}</p>

            <div dangerouslySetInnerHTML={{ __html: arch.fullContent }} />

            <div style={{ marginTop: '60px', paddingTop: '20px', borderTop: '1px solid #eee' }}>
              <button className="btn-secondary" style={{ width: '100%' }} onClick={() => history.goBack()}>
                내 결과로 돌아가기
              </button>
            </div>
          </motion.div>
        );
      };

      return (
        <div className="container" style={{ paddingTop: '40px' }}>
          {selectedId ? renderDetail() : renderList()}
        </div>
      );
    };

    const LimitationsPage = () => {
      const history = useHistory();
      return (
        <div className="container" style={{ paddingTop: '60px', paddingBottom: '60px' }}>
          <h1 className="text-h1" style={{ marginBottom: '40px' }}>유의사항 및 한계점</h1>

          <div className="text-body" style={{ background: '#F9FAFB', padding: '32px', borderRadius: '12px' }}>
            <h3 className="text-h2" style={{ marginBottom: '16px' }}>“아키타입은 감옥이 아니라 도구입니다”</h3>
            <p>진단 결과를 확인하기 전, 다음의 사항들을 반드시 숙지해 주시기 바랍니다. 본 아키타입 모델의 목적은 개인을 분류하는 것이 아니라 <strong>사고의 확장을 돕는 것</strong>입니다.</p>

            <br />
            <h4 className="text-h3">1. 고착된 성격이 아닌 ‘현재의 상태’입니다.</h4>
            <p>아키타입은 고정된 지능이 아닙니다. 당신이 속한 팀의 성격, 현재 수행 중인 프로젝트의 단계, 혹은 당신의 직무에 따라 주된 아키타입은 언제든 변할 수 있습니다. 결과에 스스로를 가두지 마십시오.</p>

            <br />
            <h4 className="text-h3">2. 모든 아키타입에는 ‘지적 그림자’가 존재합니다.</h4>
            <p>강점이 강할수록 그 이면의 약점도 뚜렷해집니다. 예를 들어 ‘탐정’의 날카로운 분석력은 ‘분석 마비’를 야기할 수 있고, ‘판사’의 결단력은 ‘독단’으로 흐를 수 있습니다. 자신의 아키타입이 가진 그림자를 인지하는 것이 성장의 핵심입니다.</p>

            <br />
            <h4 className="text-h3">3. ‘나쁜 결과’는 없습니다. ‘누락된 관점’만 있을 뿐입니다.</h4>
            <p>낮은 점수가 나온 아키타입은 당신의 능력이 부족함을 뜻하지 않습니다. 다만 문제정의 과정에서 당신이 상대적으로 덜 중요하게 생각했던 영역임을 의미합니다. 훌륭한 팀은 서로의 부족한 아키타입을 보완해 줄 때 완성됩니다.</p>

            <br />
            <h4 className="text-h3">4. 관찰에서 멈추지 말고 ‘행동’으로 연결하십시오.</h4>
            <p>이 테스트의 목적은 당신의 성향을 아는 것에 그치지 않습니다. 당신의 아키타입이 가진 강점을 팀의 전략으로 치환하고, 누락된 아키타입의 질문을 의도적으로 던짐으로써 <strong>‘문제정의의 수준’</strong>을 높이는 데 목적이 있습니다.</p>
          </div>

          <button className="btn-primary" style={{ marginTop: '40px', width: '100%' }} onClick={() => history.goBack()}>
            확인했습니다
          </button>
        </div>
      );
    };

    // --- LOGIC: Rule-based Interpretation Engine ---
    const generateInterpretation = (p, s, u) => {
      // 1. Core Identity
      let text = `당신은 <strong>${p.name.split(' (')[0]}</strong>의 성향을 중심으로 세상을 바라봅니다. `;

      // 2. Combination Logic (Primary + Secondary)
      const isAnalytic = ['Engineer', 'Scientist', 'Economist', 'Detective', 'Cartographer'].includes(p.id);
      const isEmpathic = ['Anthropologist', 'Journalist'].includes(p.id);

      if (p.id === s.id) {
        text += `특히 한 가지 사고방식이 압도적으로 발달해 있어, 해당 분야의 전문가적 통찰을 보여주지만 때로는 시야가 좁아질 수 있음을 주의해야 합니다.<br/><br/>`;
      } else {
        text += `동시에 <strong>${s.name.split(' (')[0]}</strong>의 기질을 보조 무기로 활용하여 균형을 잡고 있군요.<br/><br/>`;
      }

      // 3. Synergy Sentence
      text += `<strong>💡 강점의 결합</strong><br/>`;
      text += `당신은 ${p.coreQuestion}라고 묻는 본능적인 감각을 가지고 있으며, 이를 해결하는 과정에서 ${s.coreQuestion.replace('“', '').replace('”', '')}라는 질문을 더해 문제를 입체적으로 파악합니다. `;

      if (isAnalytic && ['Anthropologist', 'Journalist'].includes(s.id)) {
        text += `논리적인 분석력에 사람에 대한 이해가 더해져, '차가운 이성'과 '따뜻한 공감'을 동시에 발휘할 수 있는 잠재력이 있습니다. `;
      } else if (isEmpathic && ['Scientist', 'Economist', 'Systems Thinker'].includes(s.id)) {
        text += `사람에 대한 깊은 공감을 바탕으로 하되, 이를 현실적인 시스템이나 숫자로 증명해내는 탁월한 설득력을 가질 수 있습니다. `;
      } else {
        text += `이 두 가지 질문의 조합은 문제의 본질을 뚫고 지나가는 강력한 송곳과 같습니다. `;
      }
      text += `<br/><br/>`;

      // 4. Shadow/Blindspot Warning
      text += `<strong>⚠️ 주의할 점 (Shadow)</strong><br/>`;
      text += `반면, <strong>${u.name.split(' (')[0]}</strong> 성향이 가장 낮게 나타났습니다. `;
      text += `이는 당신이 문제 해결 과정에서 "${u.coreQuestion.replace('“', '').replace('”', '')}"라는 질문을 놓치기 쉽다는 것을 의미합니다.<br/>`;

      const shadowRisks = {
        'Anthropologist': '사용자의 실제 행동을 관찰하지 않고 책상 위에서만 고민하다가, 아무도 원하지 않는 해결책을 만들 위험이 있습니다.',
        'Journalist': '팀 내부의 논리에만 갇혀, 실제 이해관계자들의 다양한 목소리를 듣지 못할 수 있습니다.',
        'Scientist': '직관에만 의존하여 "내 느낌이 맞아"라고 우기다가, 객관적인 검증 기회를 놓칠 수 있습니다.',
        'Economist': '멋진 아이디어에 취해 비용과 현실적인 제약 조건을 무시하다가 프로젝트를 중단시킬 위험이 있습니다.',
        'Cartographer': '문제의 범위를 정하지 못해 모든 것을 다 해결하려다 에너지가 분산될 수 있습니다.',
        'Detective': '현상만 수습하려다 진짜 원인을 놓쳐, 같은 문제가 반복해서 터지는 상황을 겪을 수 있습니다.',
        'Systems Thinker': '당장의 문제 해결에만 급급해, 그 해결책이 불러올 다른 부작용을 예측하지 못할 수 있습니다.',
        'Philosopher': '방법론에만 매몰되어 "근본적으로 이것이 왜 필요한가"하는 가치 판단을 소홀히 할 수 있습니다.',
        'Judges': '우선순위를 정하지 못해 모든 요청을 다 들어주려다 프로젝트의 방향성을 잃을 수 있습니다.',
        'Scenario Planner': '당장의 성과에만 집중해, 미래에 닥쳐올 리스크를 대비하지 못할 수 있습니다.'
      };

      text += `${shadowRisks[u.id] || ''}<br/><br/>`;

      // 5. Final Advice
      text += `<strong>🚀 Action Plan</strong><br/>`;
      text += `다음 회의에서는 의식적으로 <strong>"${u.coreQuestion.replace('“', '').replace('”', '')}"</strong>라는 질문을 먼저 던져보세요. 당신의 강력한 주 무기에 이 질문이 더해질 때, 비로소 완전한 문제정의가 완성될 것입니다.`;

      return text;
    };

    const AnimatedRoutes = () => {
      const location = useLocation();
      return (
        <AnimatePresence mode="wait">
          <Switch location={location} key={location.pathname}>
            <Route exact path="/" component={LandingPage} />
            <Route path="/intro" component={IntroPage} />
            <Route path="/test" component={TestPage} />
            <Route path="/result" component={ResultPage} />
            <Route path="/explore" component={ExplorePage} />
            <Route path="/limitations" component={LimitationsPage} />
          </Switch>
        </AnimatePresence>
      );
    };

    const App = () => {
      return (
        <HashRouter>
          <div className="app-container">
            <AnimatedRoutes />
          </div>
        </HashRouter>
      );
    };

    const root = document.getElementById('root');
    ReactDOM.render(<App />, root);
  </script>
</body>

</html>